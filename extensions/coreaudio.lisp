(in-package #:cl-user)
(defpackage #:org.shirakumo.fraf.mixed.coreaudio
  (:use #:cl)
  (:local-nicknames
   (#:mixed #:org.shirakumo.fraf.mixed)
   (#:mixed-cffi #:org.shirakumo.fraf.mixed.cffi)
   (#:coreaudio #:org.shirakumo.fraf.mixed.coreaudio.cffi))
  (:export
   #:coreaudio-error
   #:code
   #:drain))
(in-package #:org.shirakumo.fraf.mixed.coreaudio)

(let ((value NIL))
  (defun default-run-loop-mode ()
    (or value (setf value (coreaudio::cfstr "kCFRunLoopDefaultMode")))))

(define-condition coreaudio-error (error)
  ((code :initarg :code :accessor code))
  (:report (lambda (c s) (format s "CoreAudio error ~d" (code c)))))

(defmacro with-error (() &body body)
  (let ((error (gensym "ERROR")))
    `(let ((,error (progn ,@body)))
       (when (/= ,error 0)
         (error 'coreaudio-error :code ,error)))))

(defmacro with-no-interrupts (() &body body)
  ;; On SBCL using WITHOUT-INTERRUPTS would cause interrupts
  ;; to be processed explicitly on exit. We want to avoid that.
  #+sbcl `(let ((sb-sys:*interrupts-enabled* NIL)
                (sb-kernel:*gc-inhibit* T))
            ,@body)
  #+ccl `(ccl:without-interrupts
           ,@body)
  #-(or sbcl ccl) `(progn ,@body))

(defun strint (string)
  (let ((int 0))
    (setf (ldb (byte 8 0) int) (char-code (char string 3)))
    (setf (ldb (byte 8 8) int) (char-code (char string 2)))
    (setf (ldb (byte 8 16) int) (char-code (char string 1)))
    (setf (ldb (byte 8 24) int) (char-code (char string 0)))
    int))

(defun create-component-description (description)
  ;; This is always the same. Why we need this at all, I don't know. #justapplethings
  (setf (coreaudio:audio-component-description-component-type description)
        coreaudio:kAudioUnitType_Output)
  (setf (coreaudio:audio-component-description-component-sub-type description)
        coreaudio:kAudioUnitSubType_DefaultOutput)
  (setf (coreaudio:audio-component-description-component-manufacturer description)
        coreaudio:kAudioUnitManufacturer_Apple)
  (setf (coreaudio:audio-component-description-component-flags description)
        0)
  (setf (coreaudio:audio-component-description-component-flags-mask description)
        0)
  description)

(defun create-stream-description (stream samplerate channels format)
  (setf (coreaudio:audio-stream-basic-description-sample-rate stream)
        (coerce samplerate 'double-float))
  (setf (coreaudio:audio-stream-basic-description-format-id stream)
        coreaudio:kAudioFormatLinearPCM)
  (setf (coreaudio:audio-stream-basic-description-format-flags stream)
        (ecase format
          ((:double :float) '(:native :float :packed))
          ((:int8 :int16 :int24 :int32 :int64) '(:native :signed :packed))
          ((:uint8 :uint16 :uint24 :uint32 :uint64) '(:native :packed))))
  (setf (coreaudio:audio-stream-basic-description-bytes-per-frame stream)
        (* channels (mixed:samplesize format)))
  (setf (coreaudio:audio-stream-basic-description-channels-per-frame stream)
        channels)
  (setf (coreaudio:audio-stream-basic-description-bits-per-channel stream)
        (* 8 (mixed:samplesize format)))
  (setf (coreaudio:audio-stream-basic-description-bytes-per-packet stream)
        (coreaudio:audio-stream-basic-description-bytes-per-frame stream))
  (setf (coreaudio:audio-stream-basic-description-frames-per-packet stream)
        1)
  stream)

(defun decode-stream-description (stream)
  (let ((flags (coreaudio:audio-stream-basic-description-format-flags stream))
        (bits (coreaudio:audio-stream-basic-description-bits-per-channel stream)))
    (list (round (coreaudio:audio-stream-basic-description-sample-rate stream))
          (coreaudio:audio-stream-basic-description-channels-per-frame stream)
          (cond ((find :float flags)
                 (ecase bits (32 :float) (64 :double)))
                ((find :signed flags)
                 (ecase bits (8 :int8) (16 :int16) (24 :int24) (32 :int32) (64 :int64)))
                (T
                 (ecase bits (8 :uint8) (16 :uint16) (24 :uint24) (32 :uint32) (64 :uint64)))))))

(defun create-callback-description (callback data)
  (setf (coreaudio:au-render-callback-struct-input-proc callback)
        (cffi:callback buffer-render))
  (setf (coreaudio:au-render-callback-struct-input-proc-ref-con callback)
        data)
  callback)

(defun get-default-device ()
  (cffi:with-foreign-objects ((address '(:struct coreaudio::audio-object-property-address))
                              (size :uint32)
                              (id :uint32))
    (setf (coreaudio::audio-object-property-address-selector address) (strint "dOut"))
    (setf (coreaudio::audio-object-property-address-scope address) (strint "glob"))
    (setf (coreaudio::audio-object-property-address-element address) 0)
    (setf (cffi:mem-ref size :uint32) (cffi:foreign-type-size :uint32))
    (with-error ()
      (coreaudio::audio-object-get-property-data 1 address 0 (cffi:null-pointer) size id))
    (cffi:mem-ref id :uint32)))

(defun get-device-sample-rate (&optional (device (get-default-device)))
  (cffi:with-foreign-objects ((address '(:struct coreaudio::audio-object-property-address))
                              (size :uint32)
                              (rate :double))
    (setf (coreaudio::audio-object-property-address-selector address) (strint "nsrt"))
    (setf (coreaudio::audio-object-property-address-scope address) (strint "glob"))
    (setf (coreaudio::audio-object-property-address-element address) 0)
    (setf (cffi:mem-ref size :uint32) (cffi:foreign-type-size :double))
    (with-error ()
      (coreaudio::audio-object-get-property-data device address 0 (cffi:null-pointer) size rate))
    (truncate (cffi:mem-ref rate :double))))

(defclass drain (mixed:drain)
  ((lock :initform (bt:make-lock "CoreAudio sync") :reader lock)
   (cvar :initform (bt:make-condition-variable :name "CoreAudio sync") :reader cvar)
   (thread :initform NIL :accessor thread)
   (buffers :initform NIL :accessor buffers)
   (queue :initform NIL :accessor queue)
   (ready :initform NIL :accessor ready)))

(defmethod initialize-instance :after ((drain drain) &key)
  (cffi:use-foreign-library coreaudio:audio-unit)
  (cffi:use-foreign-library coreaudio:audio-toolbox)
  (let ((samplerate (get-device-sample-rate))
        (pack (mixed:pack drain)))
    (setf (mixed:samplerate pack) samplerate)
    ;; KLUDGE: this makes it work at all, but introduces nasty latency.
    (setf (mixed:size pack) (max (mixed:size pack) samplerate))
    (format *error-output* "~& [CoreAudio] Matching default device sample rate ~d~%" samplerate)))

(defmethod mixed:free ((drain drain))
  (mixed:end drain)
  (when (queue drain)
    (coreaudio::audio-queue-dispose (queue drain) 1)
    (setf (queue drain) NIL)
    (setf (buffers drain) NIL)))

(defmethod mixed:start ((drain drain))
  (unless (and (thread drain) (bt:thread-alive-p (thread drain)))
    (setf (thread drain) T)
    (setf (ready drain) NIL)
    (setf (thread drain) (bt:make-thread (lambda () (render-thread drain)) :name "CoreAudioRender"))
    (loop until (ready drain)
          do (bt:with-lock-held ((lock drain))
               (bt:condition-wait (cvar drain) (lock drain) :timeout 0.1))
             (unless (bt:thread-alive-p (thread drain))
               (error "Failed to start render thread.")))))

(defmethod mixed:mix ((drain drain))
  (let ((pack (mixed:pack drain)))
    (bt:with-lock-held ((lock drain))
      (bt:condition-wait (cvar drain) (lock drain) :timeout 0.01)
      (when (= 0 (mixed:available-read pack))
        (mixed:clear pack)))))

(defmethod mixed:end ((drain drain))
  (let ((thread (thread drain)))
    (when (and thread (bt:thread-alive-p thread))
      (setf (thread drain) NIL)
      (loop while (bt:thread-alive-p thread)
            do (sleep 0.1)))))

(defun render-thread (drain)
  (float-features:with-float-traps-masked T
    (let ((pack (mixed:pack drain))
          (queue (queue drain)))
      (unless queue
        (cffi:with-foreign-objects ((queuep :pointer)
                                    (descriptor '(:struct coreaudio:audio-stream-basic-description)))
          (create-stream-description descriptor (mixed:samplerate pack) (mixed:channels pack) (mixed:encoding pack))
          (with-error ()
            (coreaudio::audio-queue-new-output descriptor (cffi:callback buffer-render) (mixed:handle drain)
                                               (coreaudio::get-current-run-loop) (default-run-loop-mode) 0 queuep))
          (setf queue (setf (queue drain) (cffi:mem-ref queuep :pointer)))
          ;; Configure output device of queue.
          (cffi:with-foreign-objects ((address '(:struct coreaudio::audio-object-property-address))
                                      (size :uint32)
                                      (id :pointer))
            (setf (coreaudio::audio-object-property-address-selector address) (strint "uid "))
            (setf (coreaudio::audio-object-property-address-scope address) (strint "outp"))
            (setf (coreaudio::audio-object-property-address-element address) 0)
            (setf (cffi:mem-ref size :uint32) (cffi:foreign-type-size :pointer))
            (with-error ()
              (coreaudio::audio-object-get-property-data (get-default-device) address 0 (cffi:null-pointer) size id))
            (with-error ()
              (coreaudio::audio-queue-set-property queue (strint "aqcd") id (cffi:foreign-type-size :pointer))))
          (let ((buffers (make-array 2)))
            (cffi:with-foreign-objects ((buffer :pointer))
              (dotimes (i (length buffers))
                (with-error ()
                  (coreaudio::audio-queue-allocate-buffer queue (mixed:size pack) buffer))
                (let ((buffer (setf (aref buffers i) (cffi:mem-ref buffer :pointer))))
                  (static-vectors:fill-foreign-memory (coreaudio::audio-buffer-data buffer) (coreaudio::audio-buffer-capacity buffer) 0)
                  (setf (coreaudio::audio-buffer-size buffer) (coreaudio::audio-buffer-capacity buffer))
                  (with-error ()
                    (coreaudio::audio-queue-enqueue-buffer queue buffer 0 (cffi:null-pointer))))))
            (setf (buffers drain) buffers))))
      (with-error ()
        (coreaudio::audio-queue-start queue (cffi:null-pointer)))
      (setf (ready drain) T)
      (bt:condition-notify (cvar drain))
      (loop while (thread drain)
            do (coreaudio::run-loop (default-run-loop-mode) 0.1d0 1))
      (coreaudio::audio-queue-stop queue 0))))

(cffi:defcallback buffer-render :void ((handle :pointer) (queue :pointer) (buffer :pointer))
  (declare (ignore queue)) ;; Apparently this queue is a queue we should not be using? wtf.
  (declare (optimize speed))
  (buffer-render handle buffer))

(defun buffer-render (handle buffer)
  (let* ((drain (mixed:pointer->object handle))
         (pack (mixed:pack drain))
         (total (coreaudio::audio-buffer-capacity buffer))
         (remaining total)
         (ptr (coreaudio::audio-buffer-data buffer)))
    (loop (mixed:with-buffer-tx (data start size pack :size remaining)
            (when (< 0 size)
              (static-vectors:replace-foreign-memory ptr (mixed:data-ptr) size)
              (mixed:finish size)
              (cffi:incf-pointer ptr size)
              (decf remaining size)))
          (bt:condition-notify (cvar drain))
          (if (= remaining total)
              (bt:with-lock-held ((lock drain))
                (bt:condition-wait (cvar drain) (lock drain) :timeout 0.1))
              (return)))
    (coreaudio::audio-queue-enqueue-buffer* (queue drain) buffer 0 (cffi:null-pointer)
                                            0 (floor remaining (mixed:framesize pack))
                                            0 (cffi:null-pointer)
                                            (cffi:null-pointer) (cffi:null-pointer))))
